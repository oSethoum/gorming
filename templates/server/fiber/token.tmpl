package handlers

import (
	"{{ .Config.Package }}/db"
	"context"
	"errors"
	"strings"

	"aidanwoods.dev/go-paseto"
	"github.com/gofiber/fiber/v2"
)

func Protected(c *fiber.Ctx) error {

	resource := c.Params("resource")
	action := ""
	switch c.Method() {
	case "GET":
		action = "query"
	case "POST":
		action = "create"
	case "PATCH":
		action = "update"
	case "DELETE":
		action = "delete"
	}

	// TODO: allow public actions here

	tokenString := c.Cookies("token")
	if tokenString == "" {
		if authorization, ok := c.GetReqHeaders()["Authorization"]; ok && len(authorization) > 0 {
			tokenString = authorization[0]
		}
	}

	key, err := paseto.V4SymmetricKeyFromHex(keyString)
	if err != nil {
		return Error(c, err, fiber.StatusInternalServerError)
	}

	token, err := paseto.NewParser().ParseV4Local(key, tokenString, nil)
	if err != nil {
		return Error(c, errors.New("invalid access token"), fiber.StatusUnauthorized)
	}

	deniedActions := new(map[string]string)
	err = token.Get("denied_actions", deniedActions)
	if err != nil {
		return Error(c, err, fiber.StatusInternalServerError)
	}

	deniedFields := new(map[string]string)
	err = token.Get("denied_fields", deniedActions)
	if err != nil {
		return Error(c, err, fiber.StatusInternalServerError)
	}

	actions := (*deniedActions)[resource]
	if strings.Contains(actions, action) || strings.Contains(actions, "all") {
		return Error(c, errors.New("authorization: unauthorized access to resource"), fiber.StatusUnauthorized)
	}

	ctx := context.WithValue(c.UserContext(), db.DeniedActionsKey, deniedActions)
	ctx = context.WithValue(ctx, db.DeniedFieldsKey, deniedFields)
	c.SetUserContext(ctx)
	return c.Next()
}
