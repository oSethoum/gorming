package handlers

import (
	"net/http"
	"sync"

	"github.com/gorilla/websocket"
	"github.com/labstack/echo/v4"
)

type (
	Action = string
	Kind   = string

	InMessage struct {
		Action Action   `json:"action,omitempty"`
		Events []string `json:"events,omitempty"`
	}

	OutMessage struct {
		Kind  Kind   `json:"kind,omitempty"`
		Event string `json:"event,omitempty"`
		Error any    `json:"error,omitempty"`
		Data  any    `json:"data,omitempty"`
	}

	BusMessage struct {
		Event string `json:"event,omitempty"`
		Data  any    `json:"data,omitempty"`
	}
)

var (
	ActionSubscribe      = Action("subscribe")
	ActionUnsubscribe    = Action("unsubscribe")
	ActionUnsubscribeAll = Action("unsubscribeAll")
	ActionDisconnect     = Action("disconnect")

	KindConnected    = Kind("connected")
	KindDisconnected = Kind("disconnected")
	KindNotify       = Kind("notify")
	KindWarning      = Kind("warning")
	KindError        = Kind("error")
	upgrader         = websocket.Upgrader{
		CheckOrigin: func(r *http.Request) bool {
			return true
		},
	}
	mutex = sync.Mutex{}
	subs  = make(map[string]map[*websocket.Conn]bool, 0)
)

func subscribe(events []string, c *websocket.Conn) {
	mutex.Lock()
	for _, event := range events {
		m, ok := subs[event]
		if !ok {
			m = make(map[*websocket.Conn]bool)
		}
		m[c] = true
		subs[event] = m
	}
	mutex.Unlock()
}

func unsubscribe(events []string, c *websocket.Conn) {
	mutex.Lock()
	for _, event := range events {
		m, ok := subs[event]
		if ok {
			delete(m, c)
			if len(m) == 0 {
				delete(subs, event)
			} else {
				subs[event] = m
			}
		}
	}
	mutex.Unlock()
}

func Subscription(c echo.Context) error {
	ws, err := upgrader.Upgrade(c.Response(), c.Request(), nil)
	if err != nil {
		println(err.Error())
		return err
	}
	defer ws.Close()
	ws.WriteJSON(&OutMessage{
		Kind: KindConnected,
	})
	events := []string{}
	for {
		m := new(InMessage)
		err := ws.ReadJSON(m)
		if err != nil {
			if websocket.IsCloseError(err) || websocket.IsUnexpectedCloseError(err) {
				unsubscribe(events, ws)
				return err
			}
			ws.WriteJSON(OutMessage{
				Kind:  KindError,
				Error: err.Error(),
			})
			continue
		}
		switch m.Action {
		case ActionSubscribe:
			var appended = []string{}
			events, appended = appendValues(events, m.Events...)
			subscribe(appended, ws)
		case ActionUnsubscribe:
			var removed = []string{}
			events, removed = removeValues(events, m.Events...)
			unsubscribe(removed, ws)
		case ActionUnsubscribeAll:
			unsubscribe(events, ws)
			events = []string{}
		case ActionDisconnect:
			unsubscribe(events, ws)
			return nil
		}
	}
}

func Broadcast(event string, data any) {
	mutex.Lock()
	if m, ok := subs[event]; ok {
		for ws := range m {
			go ws.WriteJSON(OutMessage{
				Kind:  KindNotify,
				Event: event,
				Data:  data,
			})
		}
	}
	mutex.Unlock()
}