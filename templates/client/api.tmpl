import type { TQuery, TSchema } from "./types";

export type ApiResponseError = {
   type: "validation" | "database" | "other";
   index?: number;
   message: string;
   validation?: Array<{
      field: string;
      tag: string;
      param?: string;
      value: string;
   }>;
   database?: {
      field?: string;
      constraint?: string;
   };
};

export type ApiResponse<T> = {
   code: number;
   data?: T;
   error?: ApiResponseError;
   status: "success" | "error";
};

export type Action = "query" | "create" | "update" | "delete";

export type Event = `${keyof TSchema}:${Action}`;

export type Kind = "subscribe" | "unsubscribe" | "unsubscribe-all" | "connected" | "notify";

export type Message<T = any> = {
   kind: Kind;
   event: Event | string;
   data: T;
};

const stringify = (data: any) => JSON.stringify(data);
const parse = (data: string) => JSON.parse(data);

export type Fetch = typeof fetch;
export type Callback<T = any> = (message: Message<T>) => void;

let baseURL = "";
let socket: WebSocket | undefined;
let eventCallbacks: Map<Event, Callback[]> | undefined;

const ws = () => {
   if (socket) return;
   eventCallbacks = new Map<Event, Callback[]>();
   const wsUrl = baseURL.replace(/^http/, "ws") + "/subscription";
   socket = new WebSocket(wsUrl);

   socket.onerror = (e) => {
      console.error(e);
   };

   socket.onclose = () => {};

   socket.onmessage = (e) => {
      const message = parse(e.data);

      switch (message.kind) {
         case "notify":
            const callbacks = eventCallbacks?.get(message.event);
            callbacks?.forEach((callback) => callback(message));
            break;
      }
   };
};

async function request<T>(url: string, init?: RequestInit & { query?: object }): Promise<ApiResponse<T>> {
   const path = url;
   if (init?.query) {
      url = `${url}?query=${encodeURIComponent(JSON.stringify(init.query))}`;
   }

   const method = init?.method || "GET";
   const headers = {
      ...init?.headers,
   };

   let response = await fetch(`${baseURL}${url}`, {
      method,
      ...init,
      headers,
      credentials: "include",
   });

   const contentType = response.headers.get("content-type");
   if (contentType == "application/json") {
      const json = await response.json();
      console.log({
         path,
         query: init?.query,
         body: init?.body,
         response: json,
      });
      return json;
   } else {
      const json: ApiResponse<T> = {
         code: 400,
         status: "error",
         error: {
            type: "other",
            message: await response.text(),
         },
      };
      console.log({
         path,
         query: init?.query,
         body: init?.body,
         response: json,
      });
      return json;
   }
}

function send(message: any) {
   ws();
   if (socket) {
      if (socket.readyState != WebSocket.OPEN) {
         socket!.onopen = () => {
            socket?.send(stringify(message));
         };
      } else {
         socket?.send(stringify(message));
      }
   } else {
      throw new Error("Error Connecting to websocket");
   }
}

export const createApi = (url: string) => {
   baseURL = url;
   return {
      request,

      async query<T extends keyof TSchema>(resource: T, query?: TQuery<T>) {
         return request<{ result: Array<TSchema[T]["type"]>; count: number }>(`/${resource}`, { query });
      },

      async create<T extends keyof TSchema>(resource: T, input: Array<TSchema[T]["create"]>) {
         return request<Array<TSchema[T]["type"]>>(`/${resource}`, {
            method: "POST",
            headers: {
               "content-type": "application/json",
            },
            body: JSON.stringify(input),
         });
      },

      async update<T extends keyof TSchema>(resource: T, input: Array<TSchema[T]["update"]>) {
         return request<Array<TSchema[T]["type"]>>(`/${resource}`, {
            method: "PATCH",
            headers: {
               "content-type": "application/json",
            },
            body: JSON.stringify(input),
         });
      },

      async delete<T extends keyof TSchema>(resource: T, where: TQuery<T>["where"]) {
         return request<Array<TSchema[T]["type"]>>(`/${resource}`, {
            method: "DELETE",
            headers: {
               "content-type": "application/json",
            },
            body: JSON.stringify(where),
         });
      },

      subscribe(events: Event[], callback: Callback) {
         events = events.filter((event, index) => events.indexOf(event) == index);
         send({ events, action: "subscribe" });
         events.forEach((event) => {
            eventCallbacks?.set(event, [...(eventCallbacks?.get(event) || []), callback]);
         });
      },

      unsubscribe(events: Event[], callback?: Callback) {
         events = events.filter((event, index) => events.indexOf(event) == index);
         send({ events, action: "unsubscribe" });
         if (callback) {
            events.forEach((event) => {
               eventCallbacks?.set(event, eventCallbacks?.get(event)?.filter((cb) => cb != callback) || []);
            });
         } else {
            events.forEach((event) => {
               eventCallbacks?.set(event, []);
            });
         }
      },

      unsubscribeAll() {
         send({ action: "unsubscribe-all" });
         eventCallbacks?.clear();
      },
   };
};
