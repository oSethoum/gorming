import type { TQuery, TSchema } from "./types";

export type ResponseError =
   | {
        type: "validation";
        details: Array<{
           field: string;
           tag: string;
           param?: string;
           value: string;
        }>;
     }
   | {
        type: "database";
        details: {
           field?: string;
           constraint?: string;
           error: string;
        };
     }
   | {
        type: "other";
        details: any;
     };

export type Response<T> = {
   code: number;
   data?: T;
   error?: ResponseError;
   status: "success" | "error";
};

export type Action = "query" | "create" | "update" | "delete";

export type Event = `${keyof TSchema}:${Action}`;

export type Kind =
   | "subscribe"
   | "unsubscribe"
   | "unsubscribe-all"
   | "connected"
   | "notify";

export type Message<T = any> = {
   kind: Kind;
   event: Event | string;
   data: T;
};

const stringify = (data: any) => JSON.stringify(data);
const parse = (data: string) => JSON.parse(data);

export type Fetch = typeof fetch;
export type Callback<T = any> = (message: Message<T>) => void;

export class Api {
   private readonly baseURL;
   private static instance: Api;
   private callbacks?: Map<Event, Callback[]>;
   private socket?: WebSocket;
   private fetch: Fetch = fetch;

   public static new(url: string, newFetch?: Fetch) {
      if (!Api.instance) {
         Api.instance = new Api(url);
      }
      if (!!newFetch) {
         Api.instance.fetch = newFetch;
      }
      return Api.instance;
   }

   private ws() {
      if (this.socket) return;
      this.callbacks = new Map<Event, Callback[]>();
      const wsUrl = this.baseURL.replace(/^http/, "ws") + "/subscription";
      this.socket = new WebSocket(wsUrl);

      this.socket.onerror = (e) => {
         console.error(e);
      };

      this.socket.onclose = () => {};

      this.socket.onmessage = (e) => {
         const message = parse(e.data);

         switch (message.kind) {
            case "notify":
               const callbacks = this.callbacks?.get(message.event);
               callbacks?.forEach((callback) => callback(message));
               break;
         }
      };
   }

   private constructor(url: string) {
      this.baseURL = url.replace(/\/+$/, "");
   }

   async request<T>(url: string, init?: RequestInit): Promise<Response<T>> {
      const method = init?.method || "GET";
      const headers = {
         ...init?.headers,
      };
      let response = await this.fetch(`${this.baseURL}${url}`, {
         method,
         ...init,
         headers,
      });
      return await response.json();
   }

   async query<T extends keyof TSchema>(resource: T, query?: TQuery<T>) {
      const url = query
         ? `/${resource}?query=${encodeURIComponent(JSON.stringify(query))}`
         : `/${resource}`;
      return this.request<
         { [key in T]: Array<TSchema[T]["type"]> } & { count: number }
      >(url);
   }

   async create<T extends keyof TSchema>(
      resource: T,
      input: Array<TSchema[T]["create"]>
   ) {
      return this.request(`/${resource}`, {
         method: "POST",
         headers: {
            "content-type": "application/json",
         },
         body: JSON.stringify(input),
      });
   }

   async update<T extends keyof TSchema>(
      resource: T,
      input: Array<TSchema[T]["update"]>
   ) {
      return this.request<Array<TSchema[T]["type"]>>(`/${resource}`, {
         method: "PATCH",
         headers: {
            "content-type": "application/json",
         },
         body: JSON.stringify(input),
      });
   }

   async delete<T extends keyof TSchema>(
      resource: T,
      where: TQuery<T>["where"]
   ) {
      return this.request<Array<TSchema[T]["type"]>>(`/${resource}`, {
         method: "DELETE",
         headers: {
            "content-type": "application/json",
         },
         body: JSON.stringify(where),
      });
   }

   private send(message: any) {
      this.ws();
      if (this.socket) {
         if (this.socket.readyState != WebSocket.OPEN) {
            this.socket!.onopen = () => {
               this.socket?.send(stringify(message));
            };
         } else {
            this.socket?.send(stringify(message));
         }
      } else {
         throw new Error("Error Connecting to websocket");
      }
   }

   subscribe(events: Event[], callback: Callback) {
      events = events.filter((event, index) => events.indexOf(event) == index);
      this.send({ events, action: "subscribe" });
      events.forEach((event) => {
         this.callbacks?.set(event, [
            ...(this.callbacks?.get(event) || []),
            callback,
         ]);
      });
   }

   unsubscribe(events: Event[], callback?: Callback) {
      events = events.filter((event, index) => events.indexOf(event) == index);
      this.send({ events, action: "unsubscribe" });
      if (callback) {
         events.forEach((event) => {
            this.callbacks?.set(
               event,
               this.callbacks?.get(event)?.filter((cb) => cb != callback) || []
            );
         });
      } else {
         events.forEach((event) => {
            this.callbacks?.set(event, []);
         });
      }
   }

   unsubscribeAll() {
      this.send({ action: "unsubscribe-all" });
      this.callbacks?.clear();
   }
}
